#include "stdafx.h"
#include <iostream>;
#include <string.h>;

using namespace std;

char **AddPtr(char **pp, int size, char *str); //прототип функции

int main()
{
	setlocale(LC_ALL, "rus");

	int size = 0;//количество указателей на строки
	char **pp = 0;//указатель на массив указателей, которые содержат адреса строк

	cout << "~~~~~Добавляем указатели на пять строк и заполняем строки данными~~~~~" << endl;
	//вызов функции и присваивание возвращаемого значения
	pp = AddPtr(pp, size, "11111111111111111");
	size++; //=1  увеличиваем размер массива указателей

	pp = AddPtr(pp, size, "22222222222222222");
	size++;  //2

	pp = AddPtr(pp, size, "33333333333333333");
	size++;  //3

	pp = AddPtr(pp, size, "44444444444444444");
	size++;  //4

	pp = AddPtr(pp, size, "55555555555555555");
	size++;  //5

	for (int i = 0; i < size; i++)    //показываем все строки на экран
		cout << pp[i] << endl;  //достаточно обратиться к pp[i] - это адрес строки (0-й элемент)
	cout << endl;

	for (int i = 0; i < size; i++) //освобождаем память
	{
		delete[] pp[i]; // сначала выделенную под строки      
	}
	delete[] pp; // потом выделенную под массив указателей
	return 0;
}

char **AddPtr(char **pp, int size, char *str)
{
	if (size == 0) {
		pp = new char *[size + 1]; //выделяем память для указателя на строку
	}
	else {   //если массив уже не пустой, данные надо скопировать во временный массив **copy
		char **copy = new char*[size + 1]; //создаем временный массив
		for (int i = 0; i < size; i++) //копируем в него адреса уже определенных строк
		{
			copy[i] = pp[i];
		}
		//теперь строки хранятся в адресах copy

		delete[] pp; //освобождаем память, которая указывала на строки

		pp = copy; //показываем указателю на какие адреса теперь ссылаться
	}

	pp[size] = new char[strlen(str) + 1];  //выделяем память на новую строку
	strcpy(pp[size], str);  //и копируем новую строку в элемент pp[size].

	return pp;
}